<!DOCTYPE html>
<!-- saved from url=(0046)http://m.myexception.cn/arithmetic/696515.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta name="format-detection" content="telephone=no"><meta http-equiv="Cache-Control" content="no-transform"><title>判断线段覆盖的网格 - 数据结构与算法</title><meta name="keywords" content="段覆盖,断线,网格,线段"><meta name="description" content="判断线段覆盖的格子一个正方形平面被划分成n*n的等大小的正方形部分。输入一个起点一个终点。按顺序输出从起点沿直线移动到终点所经过的小正方形部分。即按顺序输出有向线段所覆盖的正方形部分。（其中覆盖的定义为只要线段上有一个点在正方形内部就称做线段覆盖该正方形部分）。这个问题有没有什么比较高效率的算法？直觉上总是觉得应"><link href="./判断线段覆盖的网格 - 数据结构与算法_files/co.css" rel="stylesheet" type="text/css"><link rel="shortcut icon" href="http://m.myexception.cn/r/cms/www/red/img/favicon.ico" type="image/x-icon"><link rel="icon" href="http://m.myexception.cn/r/cms/www/red/img/favicon.ico" type="image/x-icon"><script type="text/javascript" async="" src="./判断线段覆盖的网格 - 数据结构与算法_files/ecom"></script><script type="text/javascript" async="" src="./判断线段覆盖的网格 - 数据结构与算法_files/ecom(1)"></script><script src="./判断线段覆盖的网格 - 数据结构与算法_files/co.js" type="text/javascript"></script><script type="text/javascript"> var cpro_id = 'u2282944';</script><script src="./判断线段覆盖的网格 - 数据结构与算法_files/cm.js" type="text/javascript"></script></head><body><div id="BAIDU_SSP__wrapper_u2282944_0" style="box-sizing: content-box; position: fixed; z-index: 2147483647; bottom: 0px; opacity: 0.9; text-align: center; display: block; font-size: 0px; width: 100%; height: 119px; background-color: rgb(0, 0, 0);"><div style="width:791px;height:119px;position:relative;margin:0 auto;"><div id="BAIDU_SSP__wrapper_u2282944_0_closebtn" style="box-sizing: content-box;position:absolute;right:0px;top:-48.75px;width:121.875px;height:48.75px;overflow:hidden;display:block;background:url(&#39;http://cpro.baidustatic.com/cpro/ui/noexpire/img/2.0.0/xuantingClose3.png&#39;) no-repeat 0 0;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled=true, sizingMethod=none, src=&#39;http://cpro.baidustatic.com/cpro/ui/noexpire/img/2.0.0/xuantingClose3.png&#39;);_background:none;cursor:pointer;background-position:center;background-size:100% 100%;z-index:2147483647;">&nbsp;</div><iframe id="iframeu2282944_0" src="./判断线段覆盖的网格 - 数据结构与算法_files/ecom.html" width="791" height="119" align="center,center" vspace="0" hspace="0" marginwidth="0" marginheight="0" scrolling="no" frameborder="0" style="border:0; vertical-align:bottom;margin:0;" allowtransparency="true"></iframe></div></div><header><div class="m_header"><a title="logo" href="http://m.myexception.cn/" class="m_logo m_home_logo"></a><a title="网站导航" href="http://m.myexception.cn/sitemap.html" class="m_daohan"></a></div></header><div class="daohang">&nbsp;&nbsp;<a href="http://m.myexception.cn/">首页</a>&nbsp;&nbsp;»&nbsp;&nbsp; <a href="http://m.myexception.cn/arithmetic/">数据结构与算法</a></div><div class="container"><div class="heading"><h1>判断线段覆盖的网格</h1><div class="heading-info">网友分享于：2013-09-15&nbsp;&nbsp;浏览：21次</div></div></div><div class="c_a_b"><script language="javascript"> c_a_b(); </script><script type="text/javascript" src="./判断线段覆盖的网格 - 数据结构与算法_files/zm.js"></script><div id="baidu_dup_1159061"></div><script type="text/javascript">(BAIDU_DUP=window.BAIDU_DUP||[]).push(['fillAsync','1159061','baidu_dup_1159061']);</script></div><article class="content"><article class="content">判断线段覆盖的格子<br>一个正方形平面被划分成n*n的等大小的正方形部分。<br>输入一个起点一个终点。<br>按顺序输出从起点沿直线移动到终点所经过的小正方形部分。<br>即按顺序输出有向线段所覆盖的正方形部分。（其中覆盖的定义为只要线段上有一个点在正方形内部就称做线段覆盖该正方形部分）。<br><br>这个问题有没有什么比较高效率的算法？<br>直觉上总是觉得应该有比较优的算法的。<br><br><font color="#e78608">------解决方案--------------------</font><br>起终点是在小格子的中心吗？这是计算机图形学的题吧？类似于屏幕像素拉直线。<br><br>如果|diff x| == | diff y |或者 |diff x| * |diff y| == 0，则沿45°的倍数方向，直接挨个输出。<br><br>否则，可以先算出直线方程，例如ax + by = c<br><br>然后沿一个方向，每次移动1，例如x起点是5，终点是9<br><br>那么就x从5到9代入方程，分别求y的坐标（求整数就行），如果y的坐标和上一个不同了，则检测漏检的一个方格，因为从一行方格到另一行方格，必然有一列经过了两个（排除45°角的前提下）。
<br><font color="#e78608">------解决方案--------------------</font><br><fieldset><legend>探讨</legend><br><br>引用:<br><br>说错了，应该是y变化了多少，就漏检了多少个格子。<br><br>其实判断一下|diff x| 和| diff y |谁大，沿着大的方向检测，另一个方向就最多漏检一个格子了。<br><br><br>感觉不太对吧。只要能漏一个格子，就能漏更多个吧。<br><br>起点终点不是在格子中央。<br></fieldset>
<br><font color="#e78608">------解决方案--------------------</font><br>1.假定每个正方形由m*m个像素构成（由坐标精度确定）。记像素坐标为（x,y）;正方形索引为(p,q).<br>2.使用快速画直线的算法，可以得到从起点（x0,y0)到终点(xt,yt) 中间每点坐标。<br>3. 我们记当前检查点位currentcheckpoint = (x_c,y_c);上一次检查点位lastcheckpoint = (x_l,y_l);<br>初始化：  (x_l,y_l) = (x_0,y_0);<br>         (x_0,y_0)对应的小正方形索引为(p_0,q_0);<br>         上一次检查点所在小正方形索引 (p_l, q_l) = (p_0 - 1 ,q_0);<br><br>  for ( i = 0; i &lt;t ; i++) {<br>        (x_c,y_c) = (x_i, y_i);<br>        if (x_c mod m == 0) {       // 当前点x坐标为m的倍数<br>               //计算y_c 与上一次检查点 y_l 之间的距离跨越了几个小正方形。&nbsp; <br>               if ( (y_c - y_l) mod m &gt; (m - y_l mod m))<br>                     numofSqure = y/m + 1;<br>               else<br>                     numofSqure = y/m;<br>               // 输出小正方形索引<br>               for (j = 0; j&lt;= numofSqure; j++) {<br>                     printf("直线跨越了(%d,%d) \n", p_l + 1, q_l + j);<br>               }<br><br>               // 修改上一次检查点相关坐标<br>               (x_l, y_l) = (x_c, y_c);<br>               (p_l, q_l) = (p_l+1 ,q_l + numofSqure);<br><br>        }<br>  }</article><div class="c_a_a"><script language="javascript"> c_a_a(); </script></div>  <div class="info-list"><section class="info-list-heading"><h2>相关解决方案</h2></section><ul class="info-list-body"> <li><a href="http://m.myexception.cn/arithmetic/1127336.html" '=""><font color="red">判断线段覆盖</font>的格子解决方案</a></li><li><a href="http://m.myexception.cn/other/1594320.html" '=""><font color="red">线段</font>树的实现求解<font color="red">网格</font>操作</a></li><li><a href="http://m.myexception.cn/program/1440408.html" '="">wikioi 3027 <font color="red">线段覆盖</font> 二</a></li><li><a href="http://m.myexception.cn/c-sharp/461467.html" '="">画<font color="red">网格</font>，<font color="red">线段</font>均分的有关问题？多谢</a></li><li><a href="http://m.myexception.cn/program/1670862.html" '="">hdu-1255-<font color="red">覆盖</font>的总面积-<font color="red">线段</font>树</a></li><li><a href="http://m.myexception.cn/program/1632287.html" '="">poj2482（至多矩形<font color="red">覆盖</font>-<font color="red">线段</font>树）</a></li><li><a href="http://m.myexception.cn/program/1619453.html" '="">hdu 1255 <font color="red">覆盖</font>的总面积 (<font color="red">线段</font>树扫描线 计算两次<font color="red">覆盖</font>的面积)</a></li><li><a href="http://m.myexception.cn/program/1727159.html" '="">hdu 1255 <font color="red">覆盖</font>的总面积  <font color="red">线段</font>树扫描线求重叠面积</a></li><li><a href="http://m.myexception.cn/program/1725869.html" '=""><font color="red">覆盖</font>的总面积（<font color="red">线段</font>树 + 扫描线 + 离散化）</a></li><li><a href="http://m.myexception.cn/program/1699974.html" '="">hdu 1255 <font color="red">覆盖</font>的总面积(<font color="red">线段</font>树&amp;扫描线&amp;重复面积)</a></li> </ul></div><div class="info-list"><section class="info-list-heading"><h2>最新解决方案</h2></section><ul class="info-list-body"> <li><a href="http://m.myexception.cn/arithmetic/1897704.html" '="">POJ3294-Life Forms 后缀数组+2分答案   大于k个字符串的最长公共子串</a></li><li><a href="http://m.myexception.cn/arithmetic/1897705.html" '="">【转】稳固排序和不稳定排序</a></li><li><a href="http://m.myexception.cn/arithmetic/1896328.html" '="">uestc poj2559 秋实大哥往打工</a></li><li><a href="http://m.myexception.cn/arithmetic/1896571.html" '="">无紧邻队列重复的队列</a></li><li><a href="http://m.myexception.cn/arithmetic/1895582.html" '="">复杂网络社区发现步骤</a></li><li><a href="http://m.myexception.cn/arithmetic/1894700.html" '="">SDUT_2146:最小小子序列和</a></li><li><a href="http://m.myexception.cn/arithmetic/1894701.html" '="">怎么在很大数量级的数据中（比如1个亿）筛选出前10万个最小值？之六</a></li><li><a href="http://m.myexception.cn/arithmetic/1894703.html" '="">OpenJudge_1321:棋盘有关问题</a></li><li><a href="http://m.myexception.cn/arithmetic/1894704.html" '="">回想深搜与剪枝初步</a></li><li><a href="http://m.myexception.cn/arithmetic/1893553.html" '="">怎么在很大数量级的数据中（比如1个亿）筛选出前10万个最小值？之五</a></li> </ul></div><footer><div class="footer-menu"><a href="http://m.myexception.cn/web-develop/">Web开发</a><a href="http://m.myexception.cn/jquery/">jQuery</a><a href="http://m.myexception.cn/html5/">HTML5</a><a href="http://m.myexception.cn/android/">Android</a><a href="http://m.myexception.cn/iphone/">Iphone</a><a href="http://m.myexception.cn/php">PHP</a><a href="http://m.myexception.cn/j2ee/">J2EE</a><a href="http://m.myexception.cn/j2se/">J2SE</a><a href="http://m.myexception.cn/c-sharp/">C#</a><a href="http://m.myexception.cn/cpp/">C++</a><a href="http://m.myexception.cn/ajax/">Ajax</a><a href="http://m.myexception.cn/iis/">IIS</a><a href="http://m.myexception.cn/apache/">Apache</a><a href="http://m.myexception.cn/mysql/">MySql</a><a href="http://m.myexception.cn/nosql/">NoSQL</a><div class="clearfix"></div></div><div class="footer-info"><div class="link"><a href="http://www.myexception.cn/arithmetic/696515.html">电脑版</a></div><div class="copyright">©MyException 手机我的异常网</div></div></footer><script src="./判断线段覆盖的网格 - 数据结构与算法_files/jquery.js" type="text/javascript"></script></article></body></html>